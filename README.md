сразу отбрасываем все алгоритмы которые в худшем случае работают за N. А значит тут только как-то отсортировать и бинарным поиском бегать.
ограничение по памяти позваляет загрузить столбец
в таблице примерно 7200 записей, которые могут содержать по 15-20 симфолов, можно примерно посчитать размер такой строки
+ 24(заголовок + всякие шелуха и выравнивание) * 7100(объектов)  + (12(заголовок массива)+30 * 2(UTF_16)) * 7100 б
  максимум 1 мб.
  Суффиксное дерево - дорого по памяти
  единственное решение  - суффиксный массив. О(n^2 log n)
  1 мб строка
  7.200 * 4 * 30(средяя длина строки)  = 1 мб массив индексов
  О(n^2 log n) - дорого, решил юзать алгоритм двойных префиксов, за доп таблицу индексов + 1 мб сверху снизил до О(n log^2 n)
  так получилось что мне пришлось еще завести List<Integer> на 2мб для того чтобы индексы возвращать получилось
  5 мб - норм подумал я. Всё сделал. у меня запускаетя только с флагом -Xmx11m.
  Пришлось снести оптимизацию и строить за О(n^2 log n)